I'll open the focused file to review the code and pinpoint issues.

[1 tool called]

I opened `src/leecode/q17.ts` and reviewed the `promisePool` implementation; I’ll point out the core issues succinctly.

### 主要问题

- **同步 while 忙等导致死循环/高占用**: `while (currentCount < n || suspendFunctions.length !== 0)` 在同步栈里疯狂循环，而异步的 `.then` 尚未执行，`suspendFunctions` 只增不减，导致死循环/内存暴涨。
- **边遍历边修改源数组**: 在 `for (const func of functions)` 期间向 `suspendFunctions`、`functions` 推入元素，逻辑不安全；`.then` 里又 `functions.push(f)` 会重复任务，还可能把 `undefined` 推入（当 `pop()` 为空时）。
- **未等待完成就返回**: 直接 `return Promise.resolve(res)`，函数会立刻返回空数组，完全没有等待任务完成。
- **并发调度错误**: 正确做法是“有空位就启动下一个任务”，而不是把任务丢到 `functions` 里循环；当前计数增加/减少与启动下一批的时机未正确衔接。
- **缺少错误处理**: 任务 `reject` 时没有在 `catch/finally` 里减少计数，会卡死。
- **类型设计不严谨**: `Promise<any>` 与未声明返回结果类型，易掩盖问题。

### 建议修正思路

- 用队列索引或队列结构管理任务；初始启动 `min(n, tasks.length)` 个。
- 在每个任务的 `finally` 中减少并发计数，并立刻启动下一个排队任务。
- 用单个 `Promise` 包裹整体流程，在全部完成时 `resolve(results)`，在任一失败时 `reject`。
- 始终在 `finally` 中做清理，避免异常导致计数不归零。

示例实现（仅作参考）：

```ts
function promisePool(
  tasks: Array<() => Promise<any>>,
  n: number
): Promise<any[]> {
  return new Promise((resolve, reject) => {
    const results: any[] = [];
    let inFlight = 0;
    let index = 0;

    const startNext = () => {
      if (index === tasks.length && inFlight === 0) return resolve(results);
      while (inFlight < n && index < tasks.length) {
        const current = tasks[index++];
        inFlight++;
        current()
          .then((v) => results.push(v))
          .catch(reject)
          .finally(() => {
            inFlight--;
            startNext();
          });
      }
    };

    startNext();
  });
}
```

- **核心要点**: 不要用同步 `while` 等异步完成；用“事件驱动/回调递归”触发下一次调度，直到所有任务结束。

## 方法 2

线程池的要点在于最大并发执行量的控制和执行结果的收集返回，这里采用 Promise.race 方法来控制最大并发量，并使用 Set 数据结构存储正在执行的任务队列，并且使用 Promise.allSettled 方法来等待执行完所有任务队列之后返回所有执行结果（此处还应该考虑 rejected 的情况，但题目设定没有 rejected 结果）。

任务遍历流程：

执行当前任务 task 并将结果保留起来加入到 queue 中；
在 task 任务的 then 方法中保存执行结果，并将当前任务移出任务队列；
判断当前任务队列的任务总数是否大于限制数，如果大于等于则使用 await + Promise.race 阻塞任务执行。
