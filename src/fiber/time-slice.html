<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>时间切片演示 - Time Slicing Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: white;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .description {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .description h2 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .description p {
      line-height: 1.6;
      margin-bottom: 10px;
    }

    .demo-section {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    @media (min-width: 768px) {
      .demo-section {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (min-width: 1200px) {
      .demo-section {
        grid-template-columns: 1fr 1fr 1fr;
      }
    }

    .demo-card {
      background: white;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .demo-card h3 {
      color: #667eea;
      margin-bottom: 15px;
      font-size: 1.5em;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    button {
      flex: 1;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      color: white;
    }

    .btn-start {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .btn-start:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
    }

    .btn-start:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .btn-stop {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .btn-stop:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(245, 87, 108, 0.4);
    }

    .status {
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      margin-bottom: 15px;
      border-left: 4px solid #667eea;
    }

    .status-label {
      font-weight: 600;
      margin-bottom: 5px;
    }

    .status-value {
      font-size: 1.2em;
      color: #667eea;
    }

    .progress-bar {
      width: 100%;
      height: 30px;
      background: #e0e0e0;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      width: 0%;
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
    }

    .log-container {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 8px;
      height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }

    .log-line {
      margin-bottom: 5px;
      padding: 3px 0;
    }

    .log-time {
      color: #858585;
      margin-right: 10px;
    }

    .interactive-test {
      background: white;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .interactive-test h3 {
      color: #667eea;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>⚡ 时间切片演示 Time Slicing Demo</h1>

    <div class="description">
      <h2>📖 什么是时间切片？</h2>
      <p>
        <strong>时间切片（Time Slicing）</strong> 是一种将长时间运行的任务分割成多个小任务的技术，
        每个小任务执行完后会让出主线程，让浏览器有机会处理用户交互和渲染更新。
      </p>
      <p>
        在这个演示中，我们展示了<strong>三种实现方式</strong>：
      </p>
      <ul style="margin-left: 20px; line-height: 1.8;">
        <li><strong>setTimeout 时间切片</strong>：使用 setTimeout(0) 让出主线程，简单有效</li>
        <li><strong>阻塞执行</strong>：不使用时间切片，页面会完全卡住</li>
        <li><strong>requestIdleCallback + RAF</strong>：智能利用浏览器空闲时间，优先保证响应性（类似 React Fiber）</li>
      </ul>
      <p style="margin-top: 10px;">
        尝试在输入框中输入内容，然后点击不同的演示按钮，观察页面响应性的差异。
      </p>
    </div>

    <div class="interactive-test">
      <h3>🎯 交互测试区域</h3>
      <p style="text-align: center; margin-bottom: 15px;">
        尝试在下面的输入框中输入内容，测试页面是否保持响应
      </p>
      <input 
        type="text" 
        id="testInput" 
        placeholder="在这里输入文字测试页面响应性..." 
        style="width: 100%; padding: 15px; font-size: 16px; border: 2px solid #667eea; border-radius: 8px; outline: none; transition: all 0.3s ease;"
        oninput="this.style.borderColor = '#28a745'; setTimeout(() => this.style.borderColor = '#667eea', 500);"
      />
    </div>

    <div class="demo-section">
      <!-- 有时间切片 -->
      <div class="demo-card">
        <h3>✅ 使用时间切片</h3>
        <div class="button-group">
          <button class="btn-start" id="startBtn1" onclick="startWithSlicing()">开始执行</button>
          <button class="btn-stop" id="stopBtn1" onclick="stopWithSlicing()" disabled>停止</button>
        </div>
        <div class="status">
          <div class="status-label">状态：</div>
          <div class="status-value" id="status1">就绪</div>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progress1">0%</div>
        </div>
        <div class="log-container" id="log1">
          <div class="log-line"><span class="log-time">[系统]</span> 准备就绪，点击"开始执行"开始演示</div>
        </div>
      </div>

      <!-- 无时间切片 -->
      <div class="demo-card">
        <h3>❌ 不使用时间切片</h3>
        <div class="button-group">
          <button class="btn-start" id="startBtn2" onclick="startWithoutSlicing()">开始执行</button>
          <button class="btn-stop" id="stopBtn2" onclick="stopWithoutSlicing()" disabled>停止</button>
        </div>
        <div class="status">
          <div class="status-label">状态：</div>
          <div class="status-value" id="status2">就绪</div>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progress2">0%</div>
        </div>
        <div class="log-container" id="log2">
          <div class="log-line"><span class="log-time">[系统]</span> 准备就绪，点击"开始执行"开始演示</div>
        </div>
      </div>

      <!-- requestIdleCallback + RAF -->
      <div class="demo-card">
        <h3>🚀 requestIdleCallback + RAF</h3>
        <div class="button-group">
          <button class="btn-start" id="startBtn3" onclick="startWithIdle()">开始执行</button>
          <button class="btn-stop" id="stopBtn3" onclick="stopWithIdle()" disabled>停止</button>
        </div>
        <div class="status">
          <div class="status-label">状态：</div>
          <div class="status-value" id="status3">就绪</div>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progress3">0%</div>
        </div>
        <div class="log-container" id="log3">
          <div class="log-line"><span class="log-time">[系统]</span> 准备就绪，点击"开始执行"开始演示</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========== time-slice.js 核心代码 ==========
    function doHeavyWork(index) {
      const start = performance.now();
      while (performance.now() - start < 5) {
        // do nothing, just wait
      }
      console.log(`Doing heavy work: ${index}`);
    }

    // ========== UI 控制变量 ==========
    let stopFlag1 = false;
    let stopFlag2 = false;

    function addLog(containerId, message) {
      const logContainer = document.getElementById(containerId);
      const time = new Date().toLocaleTimeString('zh-CN', { hour12: false });
      const logLine = document.createElement('div');
      logLine.className = 'log-line';
      logLine.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
      logContainer.appendChild(logLine);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function updateProgress(progressId, current, total) {
      const progress = Math.round((current / total) * 100);
      const progressFill = document.getElementById(progressId);
      progressFill.style.width = progress + '%';
      progressFill.textContent = progress + '%';
    }

    function updateStatus(statusId, text) {
      document.getElementById(statusId).textContent = text;
    }

    // 使用时间切片
    async function startWithSlicing() {
      stopFlag1 = false;
      document.getElementById('startBtn1').disabled = true;
      document.getElementById('stopBtn1').disabled = false;
      document.getElementById('log1').innerHTML = '';
      
      addLog('log1', '开始执行任务（使用时间切片）');
      updateStatus('status1', '执行中...');
      
      const totalTasks = 1000;
      const sliceSize = 50;
      
      // 使用时间切片执行任务
      for (let i = 0; i < totalTasks && !stopFlag1; i += sliceSize) {
        for (let j = i; j < i + sliceSize && j < totalTasks && !stopFlag1; j++) {
          doHeavyWork(j);
        }
        updateProgress('progress1', Math.min(i + sliceSize, totalTasks), totalTasks);
        if (i % 100 === 0) {
          addLog('log1', `正在处理任务 ${Math.min(i + sliceSize, totalTasks)}/${totalTasks}`);
        }
        await new Promise(resolve => setTimeout(resolve, 0)); // 让出主线程
      }
      
      if (!stopFlag1) {
        addLog('log1', '✅ 所有任务完成！');
        updateStatus('status1', '已完成');
      } else {
        addLog('log1', '⚠️ 任务已停止');
        updateStatus('status1', '已停止');
      }
      
      document.getElementById('startBtn1').disabled = false;
      document.getElementById('stopBtn1').disabled = true;
    }

    function stopWithSlicing() {
      stopFlag1 = true;
    }

    // 不使用时间切片
    async function startWithoutSlicing() {
      stopFlag2 = false;
      document.getElementById('startBtn2').disabled = true;
      document.getElementById('stopBtn2').disabled = false;
      document.getElementById('log2').innerHTML = '';
      
      addLog('log2', '⚠️ 开始执行任务（不使用时间切片 - 页面将卡住）');
      updateStatus('status2', '执行中...');
      
      // 使用 setTimeout 让日志有机会显示
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const totalTasks = 1000;
      const startTime = performance.now();
      
      // 不使用时间切片，一次性执行所有任务
      for (let i = 0; i < totalTasks && !stopFlag2; i++) {
        doHeavyWork(i);
        // 注意：这里更新进度条，但由于主线程被占用，UI 不会实时更新
        if (i % 100 === 0) {
          updateProgress('progress2', i, totalTasks);
        }
      }
      
      const endTime = performance.now();
      
      if (!stopFlag2) {
        updateProgress('progress2', totalTasks, totalTasks);
        addLog('log2', `✅ 所有任务完成！耗时：${(endTime - startTime).toFixed(2)}ms`);
        addLog('log2', '注意：在任务执行期间，页面完全无响应');
        updateStatus('status2', '已完成');
      } else {
        addLog('log2', '⚠️ 任务已停止');
        updateStatus('status2', '已停止');
      }
      
      document.getElementById('startBtn2').disabled = false;
      document.getElementById('stopBtn2').disabled = true;
    }

    function stopWithoutSlicing() {
      stopFlag2 = true;
    }

    // ========== requestIdleCallback + RAF 实现 ==========
    let stopFlag3 = false;

    /**
     * 使用 requestIdleCallback + requestAnimationFrame 实现的时间切片
     */
    async function timeSlicedWorkWithIdle(tasks = [], onProgress = null, shouldStop = () => false) {
      // requestIdleCallback 的 polyfill（兼容性处理）
      const requestIdleCallbackPolyfill = window.requestIdleCallback || function(callback) {
        const start = Date.now();
        return setTimeout(() => {
          callback({
            didTimeout: false,
            timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
          });
        }, 1);
      };

      return new Promise((resolve) => {
        let currentIndex = 0;
        const totalTasks = tasks.length;

        function processTask(deadline) {
          // 当还有剩余时间且有任务时，继续执行
          while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && currentIndex < totalTasks) {
            if (shouldStop()) {
              resolve({ completed: false, processed: currentIndex });
              return;
            }

            // 执行任务
            tasks[currentIndex]();
            currentIndex++;

            // 进度回调
            if (onProgress) {
              onProgress(currentIndex, totalTasks);
            }

            // 如果所有任务完成
            if (currentIndex >= totalTasks) {
              resolve({ completed: true, processed: currentIndex });
              return;
            }
          }

          // 如果还有任务，继续调度
          if (currentIndex < totalTasks) {
            // 使用 requestAnimationFrame 确保在下一帧之前更新
            requestAnimationFrame(() => {
              // 在下一帧中使用 requestIdleCallback 继续执行
              requestIdleCallbackPolyfill(processTask);
            });
          }
        }

        // 开始处理
        requestIdleCallbackPolyfill(processTask);
      });
    }

    // 使用 requestIdleCallback + RAF
    async function startWithIdle() {
      stopFlag3 = false;
      document.getElementById('startBtn3').disabled = true;
      document.getElementById('stopBtn3').disabled = false;
      document.getElementById('log3').innerHTML = '';
      
      addLog('log3', '开始执行任务（使用 requestIdleCallback + RAF）');
      addLog('log3', '💡 利用浏览器空闲时间执行任务');
      updateStatus('status3', '执行中...');
      
      const totalTasks = 1000;
      const startTime = performance.now();
      
      // 创建任务数组
      const tasks = [];
      for (let i = 0; i < totalTasks; i++) {
        tasks.push(() => doHeavyWork(i));
      }
      
      // 使用 requestIdleCallback + RAF 执行
      const result = await timeSlicedWorkWithIdle(
        tasks,
        (current, total) => {
          updateProgress('progress3', current, total);
          if (current % 100 === 0 || current === total) {
            addLog('log3', `正在处理任务 ${current}/${total}`);
          }
        },
        () => stopFlag3
      );
      
      const endTime = performance.now();
      
      if (result.completed) {
        addLog('log3', `✅ 所有任务完成！耗时：${(endTime - startTime).toFixed(2)}ms`);
        addLog('log3', '特点：在浏览器空闲时执行，优先保证响应性');
        updateStatus('status3', '已完成');
      } else {
        addLog('log3', '⚠️ 任务已停止');
        updateStatus('status3', '已停止');
      }
      
      document.getElementById('startBtn3').disabled = false;
      document.getElementById('stopBtn3').disabled = true;
    }

    function stopWithIdle() {
      stopFlag3 = true;
    }

    // 页面加载完成提示
    window.addEventListener('load', () => {
      console.log('✅ 时间切片演示页面加载完成');
      console.log('📦 包含三种实现方式：setTimeout、阻塞、requestIdleCallback + RAF');
    });
  </script>
</body>
</html>

